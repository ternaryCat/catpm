# frozen_string_literal: true

Catpm.configure do |config|
  # === Enable/Disable ===
  # config.enabled = Rails.env.production? || Rails.env.staging?

  # === Security ===
  # config.http_basic_auth_user = ENV["CATPM_USER"]
  # config.http_basic_auth_password = ENV["CATPM_PASSWORD"]
  # config.access_policy = ->(request) { request.env["warden"].user&.admin? }

  # === PII Filtering ===
  # config.additional_filter_parameters = [:card_number, :ssn]

  # === Instrumentation ===
  config.instrument_http = true
  config.instrument_jobs = false
  config.instrument_segments = true
  # config.instrument_net_http = false
  # config.instrument_middleware_stack = false
  # config.instrument_stack_sampler = false
  # config.instrument_call_tree = false
  # config.track_own_requests = false

  # === Auto-instrumentation ===
  # config.service_base_classes = nil                  # nil = auto-detect (ApplicationService, BaseService)
  # config.auto_instrument_methods = []                # e.g. ["Worker#process", "Gateway.charge"]

  # === Segments ===
  # config.max_segments_per_request = 50               # nil = unlimited
  # config.segment_source_threshold = 0.0              # ms — capture caller_locations above this
  # config.max_sql_length = 200                        # nil = no truncation
  # config.slow_threshold = 500                        # ms
  # config.slow_threshold_per_kind = {}                # { http: 500, job: 5_000, custom: 1_000 }
  # config.ignored_targets = []

  # === Stack Sampling ===
  # config.stack_sample_interval = 0.005               # seconds (5ms)
  # config.max_stack_samples_per_request = 200         # nil = unlimited

  # === Sampling ===
  # config.random_sample_rate = 20                     # 1 in N requests sampled randomly
  # config.max_random_samples_per_endpoint = 5         # nil = unlimited
  # config.max_slow_samples_per_endpoint = 5           # nil = unlimited
  # config.max_error_samples_per_fingerprint = 20      # nil = unlimited

  # === Errors ===
  # config.max_error_contexts = 5                      # nil = unlimited
  # config.backtrace_lines = nil

  # === Events ===
  # config.events_enabled = false
  # config.events_max_samples_per_name = 20            # nil = unlimited

  # === Buffering & Flushing ===
  # config.max_buffer_memory = 8.megabytes
  # config.flush_interval = 30                         # seconds
  # config.flush_jitter = 5                            # ±seconds
  # config.persistence_batch_size = 100

  # === Data Retention ===
  # config.retention_period = nil                      # nil = keep forever
  # config.cleanup_interval = 1.hour

  # === Downsampling ===
  # config.bucket_sizes = { recent: 1.minute, medium: 5.minutes, hourly: 1.hour, daily: 1.day, weekly: 1.week }
  # config.downsampling_thresholds = {                 # Age before tier is merged into the next coarser tier
  #   medium: 1.hour,
  #   hourly: 24.hours,
  #   daily:  1.week,
  #   weekly: 90.days
  # }

  # === Database ===
  # config.sqlite_busy_timeout = 5_000                 # ms

  # === Circuit Breaker ===
  # config.circuit_breaker_failure_threshold = 5
  # config.circuit_breaker_recovery_timeout = 60       # seconds

  # === Advanced ===
  # config.shutdown_timeout = 5                        # seconds
  # config.max_error_detail_length = 200               # truncate error detail segments
  # config.max_fingerprint_app_frames = 5              # app frames used for error fingerprint
  # config.max_fingerprint_gem_frames = 3              # gem frames used when no app frames
  # config.cleanup_batch_size = 1_000                  # rows per cleanup batch
  # config.caller_scan_depth = 50                      # max frames to scan for app code
  # config.error_handler = ->(e) { Rails.logger.error("[catpm] #{e.message}") }
end
